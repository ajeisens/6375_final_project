//
// Generated by Bluespec Compiler, version 2014.07.A (build 34078, 2014-07-30)
//
// On Mon Apr 18 18:33:11 EDT 2016
//
//
// Ports:
// Name                         I/O  size props
// RDY_putByteInput               O     1
// getByteOutput                  O     4
// RDY_getByteOutput              O     1
// RDY_doInit                     O     1 const
// ddr3client_request_get         O   601 reg
// RDY_ddr3client_request_get     O     1 reg
// RDY_ddr3client_response_put    O     1 reg
// RDY_setmode_put                O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// putByteInput_in                I     4
// doInit_x                       I     1 reg
// ddr3client_response_put        I   512 reg
// setmode_put                    I     1 unused
// EN_putByteInput                I     1
// EN_doInit                      I     1
// EN_ddr3client_response_put     I     1
// EN_setmode_put                 I     1 unused
// EN_getByteOutput               I     1
// EN_ddr3client_request_get      I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkCommPipeline(CLK,
		      RST_N,

		      putByteInput_in,
		      EN_putByteInput,
		      RDY_putByteInput,

		      EN_getByteOutput,
		      getByteOutput,
		      RDY_getByteOutput,

		      doInit_x,
		      EN_doInit,
		      RDY_doInit,

		      EN_ddr3client_request_get,
		      ddr3client_request_get,
		      RDY_ddr3client_request_get,

		      ddr3client_response_put,
		      EN_ddr3client_response_put,
		      RDY_ddr3client_response_put,

		      setmode_put,
		      EN_setmode_put,
		      RDY_setmode_put);
  input  CLK;
  input  RST_N;

  // action method putByteInput
  input  [3 : 0] putByteInput_in;
  input  EN_putByteInput;
  output RDY_putByteInput;

  // actionvalue method getByteOutput
  input  EN_getByteOutput;
  output [3 : 0] getByteOutput;
  output RDY_getByteOutput;

  // action method doInit
  input  doInit_x;
  input  EN_doInit;
  output RDY_doInit;

  // actionvalue method ddr3client_request_get
  input  EN_ddr3client_request_get;
  output [600 : 0] ddr3client_request_get;
  output RDY_ddr3client_request_get;

  // action method ddr3client_response_put
  input  [511 : 0] ddr3client_response_put;
  input  EN_ddr3client_response_put;
  output RDY_ddr3client_response_put;

  // action method setmode_put
  input  setmode_put;
  input  EN_setmode_put;
  output RDY_setmode_put;

  // signals for module outputs
  wire [600 : 0] ddr3client_request_get;
  wire [3 : 0] getByteOutput;
  wire RDY_ddr3client_request_get,
       RDY_ddr3client_response_put,
       RDY_doInit,
       RDY_getByteOutput,
       RDY_putByteInput,
       RDY_setmode_put;

  // register cyc
  reg [63 : 0] cyc;
  wire [63 : 0] cyc$D_IN;
  wire cyc$EN;

  // register inAddr
  reg [23 : 0] inAddr;
  wire [23 : 0] inAddr$D_IN;
  wire inAddr$EN;

  // register maxInAddr
  reg [23 : 0] maxInAddr;
  wire [23 : 0] maxInAddr$D_IN;
  wire maxInAddr$EN;

  // register mode
  reg mode;
  wire mode$D_IN, mode$EN;

  // register outAddr
  reg [23 : 0] outAddr;
  wire [23 : 0] outAddr$D_IN;
  wire outAddr$EN;

  // register started
  reg started;
  wire started$D_IN, started$EN;

  // ports of submodule b2p
  wire [23 : 0] b2p$response_get;
  wire [3 : 0] b2p$request_put;
  wire b2p$EN_request_put,
       b2p$EN_response_get,
       b2p$RDY_request_put,
       b2p$RDY_response_get;

  // ports of submodule ddr3ReqFifo
  wire [600 : 0] ddr3ReqFifo$D_IN, ddr3ReqFifo$D_OUT;
  wire ddr3ReqFifo$CLR,
       ddr3ReqFifo$DEQ,
       ddr3ReqFifo$EMPTY_N,
       ddr3ReqFifo$ENQ,
       ddr3ReqFifo$FULL_N;

  // ports of submodule ddr3RespFifo
  wire [511 : 0] ddr3RespFifo$D_IN, ddr3RespFifo$D_OUT;
  wire ddr3RespFifo$CLR,
       ddr3RespFifo$DEQ,
       ddr3RespFifo$EMPTY_N,
       ddr3RespFifo$ENQ,
       ddr3RespFifo$FULL_N;

  // ports of submodule p2b
  wire [23 : 0] p2b$request_put;
  wire [3 : 0] p2b$response_get;
  wire p2b$EN_request_put,
       p2b$EN_response_get,
       p2b$RDY_request_put,
       p2b$RDY_response_get;

  // ports of submodule p2w
  wire [511 : 0] p2w$response_get;
  wire [23 : 0] p2w$request_put;
  wire p2w$EN_request_put,
       p2w$EN_response_get,
       p2w$RDY_request_put,
       p2w$RDY_response_get;

  // ports of submodule w2p
  wire [511 : 0] w2p$request_put;
  wire [23 : 0] w2p$response_get;
  wire w2p$EN_request_put,
       w2p$EN_response_get,
       w2p$RDY_request_put,
       w2p$RDY_response_get;

  // rule scheduling signals
  wire CAN_FIRE_RL_b2p_to_p2w,
       CAN_FIRE_RL_ddr3_request,
       CAN_FIRE_RL_ddr3_to_w2p,
       CAN_FIRE_RL_deqTrash,
       CAN_FIRE_RL_incrCyc,
       CAN_FIRE_RL_p2w_to_ddr3,
       CAN_FIRE_RL_w2p_to_p2b,
       CAN_FIRE_ddr3client_request_get,
       CAN_FIRE_ddr3client_response_put,
       CAN_FIRE_doInit,
       CAN_FIRE_getByteOutput,
       CAN_FIRE_putByteInput,
       CAN_FIRE_setmode_put,
       WILL_FIRE_RL_b2p_to_p2w,
       WILL_FIRE_RL_ddr3_request,
       WILL_FIRE_RL_ddr3_to_w2p,
       WILL_FIRE_RL_deqTrash,
       WILL_FIRE_RL_incrCyc,
       WILL_FIRE_RL_p2w_to_ddr3,
       WILL_FIRE_RL_w2p_to_p2b,
       WILL_FIRE_ddr3client_request_get,
       WILL_FIRE_ddr3client_response_put,
       WILL_FIRE_doInit,
       WILL_FIRE_getByteOutput,
       WILL_FIRE_putByteInput,
       WILL_FIRE_setmode_put;

  // inputs to muxes for submodule ports
  wire [600 : 0] MUX_ddr3ReqFifo$enq_1__VAL_1, MUX_ddr3ReqFifo$enq_1__VAL_2;

  // action method putByteInput
  assign RDY_putByteInput = b2p$RDY_request_put ;
  assign CAN_FIRE_putByteInput = b2p$RDY_request_put ;
  assign WILL_FIRE_putByteInput = EN_putByteInput ;

  // actionvalue method getByteOutput
  assign getByteOutput = p2b$response_get ;
  assign RDY_getByteOutput = p2b$RDY_response_get && started ;
  assign CAN_FIRE_getByteOutput = p2b$RDY_response_get && started ;
  assign WILL_FIRE_getByteOutput = EN_getByteOutput ;

  // action method doInit
  assign RDY_doInit = 1'd1 ;
  assign CAN_FIRE_doInit = 1'd1 ;
  assign WILL_FIRE_doInit = EN_doInit ;

  // actionvalue method ddr3client_request_get
  assign ddr3client_request_get = ddr3ReqFifo$D_OUT ;
  assign RDY_ddr3client_request_get = ddr3ReqFifo$EMPTY_N ;
  assign CAN_FIRE_ddr3client_request_get = ddr3ReqFifo$EMPTY_N ;
  assign WILL_FIRE_ddr3client_request_get = EN_ddr3client_request_get ;

  // action method ddr3client_response_put
  assign RDY_ddr3client_response_put = ddr3RespFifo$FULL_N ;
  assign CAN_FIRE_ddr3client_response_put = ddr3RespFifo$FULL_N ;
  assign WILL_FIRE_ddr3client_response_put = EN_ddr3client_response_put ;

  // action method setmode_put
  assign RDY_setmode_put = 1'd1 ;
  assign CAN_FIRE_setmode_put = 1'd1 ;
  assign WILL_FIRE_setmode_put = EN_setmode_put ;

  // submodule b2p
  mkSerializerBTP b2p(.CLK(CLK),
		      .RST_N(RST_N),
		      .request_put(b2p$request_put),
		      .EN_request_put(b2p$EN_request_put),
		      .EN_response_get(b2p$EN_response_get),
		      .RDY_request_put(b2p$RDY_request_put),
		      .response_get(b2p$response_get),
		      .RDY_response_get(b2p$RDY_response_get));

  // submodule ddr3ReqFifo
  FIFO2 #(.width(32'd601), .guarded(32'd1)) ddr3ReqFifo(.RST(RST_N),
							.CLK(CLK),
							.D_IN(ddr3ReqFifo$D_IN),
							.ENQ(ddr3ReqFifo$ENQ),
							.DEQ(ddr3ReqFifo$DEQ),
							.CLR(ddr3ReqFifo$CLR),
							.D_OUT(ddr3ReqFifo$D_OUT),
							.FULL_N(ddr3ReqFifo$FULL_N),
							.EMPTY_N(ddr3ReqFifo$EMPTY_N));

  // submodule ddr3RespFifo
  FIFO2 #(.width(32'd512), .guarded(32'd1)) ddr3RespFifo(.RST(RST_N),
							 .CLK(CLK),
							 .D_IN(ddr3RespFifo$D_IN),
							 .ENQ(ddr3RespFifo$ENQ),
							 .DEQ(ddr3RespFifo$DEQ),
							 .CLR(ddr3RespFifo$CLR),
							 .D_OUT(ddr3RespFifo$D_OUT),
							 .FULL_N(ddr3RespFifo$FULL_N),
							 .EMPTY_N(ddr3RespFifo$EMPTY_N));

  // submodule p2b
  mkDeserializerPTB p2b(.CLK(CLK),
			.RST_N(RST_N),
			.request_put(p2b$request_put),
			.EN_request_put(p2b$EN_request_put),
			.EN_response_get(p2b$EN_response_get),
			.RDY_request_put(p2b$RDY_request_put),
			.response_get(p2b$response_get),
			.RDY_response_get(p2b$RDY_response_get));

  // submodule p2w
  mkSerializerPTW p2w(.CLK(CLK),
		      .RST_N(RST_N),
		      .request_put(p2w$request_put),
		      .EN_request_put(p2w$EN_request_put),
		      .EN_response_get(p2w$EN_response_get),
		      .RDY_request_put(p2w$RDY_request_put),
		      .response_get(p2w$response_get),
		      .RDY_response_get(p2w$RDY_response_get));

  // submodule w2p
  mkDeserializerWTP w2p(.CLK(CLK),
			.RST_N(RST_N),
			.request_put(w2p$request_put),
			.EN_request_put(w2p$EN_request_put),
			.EN_response_get(w2p$EN_response_get),
			.RDY_request_put(w2p$RDY_request_put),
			.response_get(w2p$response_get),
			.RDY_response_get(w2p$RDY_response_get));

  // rule RL_deqTrash
  assign CAN_FIRE_RL_deqTrash = ddr3RespFifo$EMPTY_N && !started ;
  assign WILL_FIRE_RL_deqTrash = CAN_FIRE_RL_deqTrash ;

  // rule RL_b2p_to_p2w
  assign CAN_FIRE_RL_b2p_to_p2w =
	     b2p$RDY_response_get && p2w$RDY_request_put && started && !mode ;
  assign WILL_FIRE_RL_b2p_to_p2w = CAN_FIRE_RL_b2p_to_p2w ;

  // rule RL_p2w_to_ddr3
  assign CAN_FIRE_RL_p2w_to_ddr3 =
	     p2w$RDY_response_get && ddr3ReqFifo$FULL_N && started && !mode ;
  assign WILL_FIRE_RL_p2w_to_ddr3 = CAN_FIRE_RL_p2w_to_ddr3 ;

  // rule RL_ddr3_request
  assign CAN_FIRE_RL_ddr3_request =
	     ddr3ReqFifo$FULL_N && started && mode && outAddr <= maxInAddr ;
  assign WILL_FIRE_RL_ddr3_request = CAN_FIRE_RL_ddr3_request ;

  // rule RL_ddr3_to_w2p
  assign CAN_FIRE_RL_ddr3_to_w2p =
	     w2p$RDY_request_put && ddr3RespFifo$EMPTY_N && started && mode ;
  assign WILL_FIRE_RL_ddr3_to_w2p = CAN_FIRE_RL_ddr3_to_w2p ;

  // rule RL_w2p_to_p2b
  assign CAN_FIRE_RL_w2p_to_p2b =
	     w2p$RDY_response_get && p2b$RDY_request_put && started && mode ;
  assign WILL_FIRE_RL_w2p_to_p2b = CAN_FIRE_RL_w2p_to_p2b ;

  // rule RL_incrCyc
  assign CAN_FIRE_RL_incrCyc = 1'd1 ;
  assign WILL_FIRE_RL_incrCyc = 1'd1 ;

  // inputs to muxes for submodule ports
  assign MUX_ddr3ReqFifo$enq_1__VAL_1 =
	     { 65'h1FFFFFFFFFFFFFFFF, inAddr, p2w$response_get } ;
  assign MUX_ddr3ReqFifo$enq_1__VAL_2 =
	     { 65'h0FFFFFFFFFFFFFFFF,
	       outAddr,
	       512'hAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA } ;

  // register cyc
  assign cyc$D_IN = cyc + 64'd1 ;
  assign cyc$EN = 1'd1 ;

  // register inAddr
  assign inAddr$D_IN = inAddr + 24'd1 ;
  assign inAddr$EN = CAN_FIRE_RL_p2w_to_ddr3 ;

  // register maxInAddr
  assign maxInAddr$D_IN = inAddr ;
  assign maxInAddr$EN = CAN_FIRE_RL_p2w_to_ddr3 ;

  // register mode
  assign mode$D_IN = doInit_x ;
  assign mode$EN = EN_doInit ;

  // register outAddr
  assign outAddr$D_IN = outAddr + 24'd1 ;
  assign outAddr$EN = CAN_FIRE_RL_ddr3_request ;

  // register started
  assign started$D_IN = 1'd1 ;
  assign started$EN = EN_doInit ;

  // submodule b2p
  assign b2p$request_put = putByteInput_in ;
  assign b2p$EN_request_put = EN_putByteInput ;
  assign b2p$EN_response_get = CAN_FIRE_RL_b2p_to_p2w ;

  // submodule ddr3ReqFifo
  assign ddr3ReqFifo$D_IN =
	     WILL_FIRE_RL_p2w_to_ddr3 ?
	       MUX_ddr3ReqFifo$enq_1__VAL_1 :
	       MUX_ddr3ReqFifo$enq_1__VAL_2 ;
  assign ddr3ReqFifo$ENQ =
	     WILL_FIRE_RL_p2w_to_ddr3 || WILL_FIRE_RL_ddr3_request ;
  assign ddr3ReqFifo$DEQ = EN_ddr3client_request_get ;
  assign ddr3ReqFifo$CLR = 1'b0 ;

  // submodule ddr3RespFifo
  assign ddr3RespFifo$D_IN = ddr3client_response_put ;
  assign ddr3RespFifo$ENQ = EN_ddr3client_response_put ;
  assign ddr3RespFifo$DEQ =
	     WILL_FIRE_RL_ddr3_to_w2p || WILL_FIRE_RL_deqTrash ;
  assign ddr3RespFifo$CLR = 1'b0 ;

  // submodule p2b
  assign p2b$request_put = w2p$response_get ;
  assign p2b$EN_request_put = CAN_FIRE_RL_w2p_to_p2b ;
  assign p2b$EN_response_get = EN_getByteOutput ;

  // submodule p2w
  assign p2w$request_put = b2p$response_get ;
  assign p2w$EN_request_put = CAN_FIRE_RL_b2p_to_p2w ;
  assign p2w$EN_response_get = CAN_FIRE_RL_p2w_to_ddr3 ;

  // submodule w2p
  assign w2p$request_put = ddr3RespFifo$D_OUT ;
  assign w2p$EN_request_put = CAN_FIRE_RL_ddr3_to_w2p ;
  assign w2p$EN_response_get = CAN_FIRE_RL_w2p_to_p2b ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        cyc <= `BSV_ASSIGNMENT_DELAY 64'd0;
	inAddr <= `BSV_ASSIGNMENT_DELAY 24'd0;
	maxInAddr <= `BSV_ASSIGNMENT_DELAY 24'd0;
	mode <= `BSV_ASSIGNMENT_DELAY 1'd0;
	outAddr <= `BSV_ASSIGNMENT_DELAY 24'd0;
	started <= `BSV_ASSIGNMENT_DELAY 1'd0;
      end
    else
      begin
        if (cyc$EN) cyc <= `BSV_ASSIGNMENT_DELAY cyc$D_IN;
	if (inAddr$EN) inAddr <= `BSV_ASSIGNMENT_DELAY inAddr$D_IN;
	if (maxInAddr$EN) maxInAddr <= `BSV_ASSIGNMENT_DELAY maxInAddr$D_IN;
	if (mode$EN) mode <= `BSV_ASSIGNMENT_DELAY mode$D_IN;
	if (outAddr$EN) outAddr <= `BSV_ASSIGNMENT_DELAY outAddr$D_IN;
	if (started$EN) started <= `BSV_ASSIGNMENT_DELAY started$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    cyc = 64'hAAAAAAAAAAAAAAAA;
    inAddr = 24'hAAAAAA;
    maxInAddr = 24'hAAAAAA;
    mode = 1'h0;
    outAddr = 24'hAAAAAA;
    started = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_getByteOutput) $display("data out:", p2b$response_get);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_p2w_to_ddr3)
	$display("[%d]Word Input: %x, addr new: %x",
		 cyc,
		 p2w$response_get,
		 inAddr);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_ddr3_request)
	$display("[%d]Call to Mem: Addr= %d,out addr: %d",
		 cyc,
		 outAddr,
		 outAddr);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_ddr3_to_w2p)
	$display("[%d]Word Output: %x", cyc, ddr3RespFifo$D_OUT);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_w2p_to_p2b)
	$display("[%d]Pixel Output: %x", cyc, w2p$response_get);
  end
  // synopsys translate_on
endmodule  // mkCommPipeline

